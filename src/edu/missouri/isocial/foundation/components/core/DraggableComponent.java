/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.missouri.isocial.foundation.components.core;

import edu.missouri.isocial.foundation.GraphView;
import edu.missouri.isocial.foundation.RelativeDirection;
import edu.missouri.isocial.foundation.components.ConnectionInfo;
import edu.missouri.isocial.foundation.components.core.brushes.DraggableComponentBrush;
import edu.missouri.isocial.foundation.components.core.model.DefaultDraggableComponentModel;
import edu.missouri.isocial.foundation.components.core.model.DraggableComponentModel;
import edu.missouri.isocial.foundation.components.core.model.LinkModel;
import edu.missouri.isocial.foundation.contextmenu.ComponentContextMenu;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 * @author Ryan
 */
public class DraggableComponent extends javax.swing.JPanel {

    /**
     * Creates new form DraggableJPanel
     */
    private GraphView editor;
    private DraggableComponentController controller;
    private List<ConnectionInfo> connections;
    private Color borderColor = Color.BLACK;
    private DraggableComponentBrush brush;
    private DraggableComponentModel model;
    private Map<RelativeDirection, List<Link>> allLinks;
    protected Map<String, Link> leftLinks;
    protected Map<String, Link> rightLinks;
    protected Map<String, Link> bottomLinks;
    private final ComponentContextMenu menu;
    private static int issues = 0;
    private int issue = 0;

    public DraggableComponent(GraphView editor, DraggableComponentModel model) {
        this.editor = editor;
        this.connections = new ArrayList<ConnectionInfo>();
        this.model = model;
        initComponents();

        this.setOpaque(false);
        issue = issues;
        incrementIssues();

        controller = new DraggableComponentController(this);
        
        //this.setSize(500, 500);

        leftLinks = new HashMap<String, Link>();
        rightLinks = new HashMap<String, Link>();
        bottomLinks = new HashMap<String, Link>();

        initializeFromModel();

        brush = new DraggableComponentBrush(this);
        menu = new ComponentContextMenu(this);


    }

    public DraggableComponentController getController() {
        return controller;
    }

    private static void incrementIssues() {
        issues += 1;
    }
    public void showContextMenu(int xOnScreen, int yOnScreen) {
        menu.showMenu(this, xOnScreen, yOnScreen);
        
    }

    public void hideContextMenu() {
        
    }
    
    public void setBorderColor(Color color) {
        this.borderColor = color;
    }

    @Override
    protected void paintComponent(Graphics g1) {
        brush.paint((Graphics2D) g1);
        //repaintConnections();
    }

    public String getID() {
        return this.model.getDisplayText() + "_" + issue;
    }
    public String getCaption() {
        return getID();
    }
    public DraggableComponentModel getModel() {
        return this.model;
    }

//    public void repaintConnections() {
//        for (ConnectionInfo connection : connections) {
//
//            Point startPoint = connection.getStartConnector().getLocationOnScreen();
//            Point endPoint = connection.getEndConnector().getLocationOnScreen();
//            this.getGraphics().setColor(Color.green);
//            this.getGraphics().drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
//            System.out.println("DRAWING CONNECTION: "
//                    + "\nSTART->(" + startPoint.x + "," + startPoint.y + ")\n"
//                    + "END->(" + endPoint.x + "," + endPoint.y + ")");
//
//
//        }
//    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 0, 51));

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(0, 400, Short.MAX_VALUE));
        layout.setVerticalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(0, 300, Short.MAX_VALUE));
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    public GraphView getEditor() {
        return editor;
    }

    /**
     * Perform any upkeep needed before this instance is removed from the editor
     */
    public void cleanup() {
        //override this.
        for (Link link : leftLinks.values()) {

            link.removeConnections();
            link.cleanup();
        }

        for (Link link : rightLinks.values()) {
            link.removeConnections();
            link.cleanup();
        }

        for (Link link : bottomLinks.values()) {
            link.removeConnections();
            link.cleanup();
        }
    }

    public Color getBorderColor() {
        return borderColor;
    }

//    @Override
//    public void setSize(int _width, int _height) {
//        super.setSize(_width, _height);
//
//        brush.setWidth(_width);
//        brush.setHeight(_height);
//    }
    protected void initializeFromModel() {
        int maxSideLinks = Math.max(model.getLeft().size(), model.getRight().size());

        double desiredHeight = Math.max(50, Link.SIDE_SIZE * ((maxSideLinks * 2) + 1) + 10);
        System.out.println("DESIRED HEIGHT: " + desiredHeight);
        double desiredWidth = Math.max(200, calculateDesiredWidth(model.getBottom()));

//        this.setMinimumSize(new Dimension(Int(desiredWidth), Int(desiredHeight)));
//        this.setPreferredSize(new Dimension(Int(desiredWidth), Int(desiredHeight)));
//        this.setMaximumSize(new Dimension(5000, 5000));
        this.setSize(Int(desiredWidth), Int(desiredHeight));
        this.getWidth();
        makeLeftLinks(desiredHeight);

        makeRightLinks(desiredHeight, desiredWidth);

        makeBottomLinks(desiredWidth, desiredHeight);
        //brush.setDraggable(this);
        
        
    }

    private int calculateDesiredWidth(List<LinkModel> bottomLinks) {
        int width = 0;
        for (LinkModel link : bottomLinks) {
            System.out.println("STRING LENGTH IN PIXELS: " + getFontMetrics(getFont()).stringWidth(link.getCaption()));
            width += getFontMetrics(getFont()).stringWidth(link.getCaption());
            width += 32;
        }
        System.out.println("CALCULATED DESIRED WIDTH: " + width);
        return width;
    }

    //<editor-fold defaultstate="collapsed" desc="legacy">
//    public void addConnector(RelativeDirection side, String fieldName) {
//        
//        //create connector
//        Link link = new Link(editor, this);
//        //<editor-fold defaultstate="collapsed" desc="comment">
//        Map<String, Link> links;
//        //add to appropriate list in map.
//        switch (side) {
//            case LEFT:
//                leftLinks.put(fieldName, link);
//                links = leftLinks;
//                break;
//            case RIGHT:
//                rightLinks.put(fieldName, link);
//                links = rightLinks;
//                break;
//            case BOTTOM:
//                bottomLinks.put(fieldName, link);
//                links = bottomLinks;
//                break;
//            default:
//                links = leftLinks;
//        }
//        //</editor-fold>
//        //add as component to this component
//        this.add(link);
//        link.setVisible(true);
//        //<editor-fold defaultstate="collapsed" desc="comment">
//        
//        //perform the analysis step
//        int numberOfConnectors = links.size();
//        int height = this.getHeight();
//        int width = this.getWidth();
//        
//        int desiredDimension = (2 * numberOfConnectors) + 1;
//        
//        //resize height if necessary
//        if (side == RelativeDirection.LEFT || side == RelativeDirection.RIGHT) {
//            //resize height
//            if (height < desiredDimension) {
//                this.setSize(height, desiredDimension);
//            }
//        } else {
//            //resize width
//            if (width < desiredDimension) {
//                this.setSize(width, desiredDimension);
//            }
//        }
//        //</editor-fold>
//        
//        switch (side) {
//            case LEFT:
//            case RIGHT:
//                
//                //relocate left connectors
//                links = leftLinks;
//                for (int index = 0; index < numberOfConnectors; index++) {
//                    Link _connector = links.get(index);
//                    height = (height * 1 / (numberOfConnectors + 1) * (index + 1));
//                    _connector.setLocation(0, height);
//                }
//                
//                //relocate right connectors
//                links = rightLinks;
//                for (int index = 0; index < numberOfConnectors; index++) {
//                    Link _connector = links.get(index);
//                    height = (height * 1 / (numberOfConnectors + 1) * (index + 1));
//                    _connector.setLocation(width - (1 / 2 * sizeOfConnectorSide), height);
//                }
//                break;
//            case TOP:
//                //reserved for top parameters
//                break;
//            case BOTTOM:
//                //reserved for bottom parameters
//                break;
//        }
//    }
    //</editor-fold>
    private void makeLeftLinks(double desiredHeight) {
        //for every link in links.
        for (int index = 0; index < model.getLeft().size(); index++) {
            //retrieve the info we need.

            LinkModel linkModel = model.getLeft().get(index);

            //build the link object
            Link link = Link.builder()
                    .withEditor(editor)
                    .withParent(this)
                    .withPosition(Link.POSITION.LEFT)
                    .withCaption(linkModel.getCaption()).build();

            //add the link to our map for quick retrieval
            leftLinks.put(linkModel.getCaption(), link);

            //formulate the correct yPosition 
            double yPosition = desiredHeight * (1.0 / (model.getLeft().size() + 1.0)) * (index + 1.0);
            link.setLocation(0, Int(yPosition));
            link.setVisible(true);

            //finally add it to ourself as a subcomponent
            add(link);
        }
    }

    private void makeRightLinks(double desiredHeight, double desiredWidth) {
        //make right links
        for (int index = 0; index < model.getRight().size(); index++) {
            LinkModel linkModel = model.getRight().get(index);

            Link link = Link.builder()
                    .withEditor(editor)
                    .withParent(this)
                    .withPosition(Link.POSITION.RIGHT)
                    .withCaption(linkModel.getCaption())
                    .build();

            rightLinks.put(linkModel.getCaption(), link);
            double yPosition = desiredHeight * (1.0 / (model.getRight().size() + 1.0)) * (index + 1.0);

            link.setLocation(Int(desiredWidth - link.getWidth()),
                    Int(yPosition));
            link.setVisible(true);
            add(link);
        }
    }

    private void makeBottomLinks(double desiredWidth, double desiredHeight) {
        //make bottom links
        for (int index = 0; index < model.getBottom().size(); index++) {
            LinkModel linkModel = model.getBottom().get(index);

            Link link = Link.builder()
                    .withEditor(editor)
                    .withParent(this)
                    .withPosition(Link.POSITION.BOTTOM)
                    .withCaption(linkModel.getCaption())
                    .build();

            bottomLinks.put(linkModel.getCaption(), link);

            double xPosition = desiredWidth * (1.0 / (model.getBottom().size() + 1.0)) * (index + 1.0);
            xPosition -= stringLengthInPixels(linkModel.getCaption()) / 2.0;
            link.setLocation(Int(xPosition), Int(desiredHeight - Link.SIDE_SIZE));
            link.setVisible(true);
            add(link);
        }
    }

    private int Int(double value) {
        return new Double(value).intValue();
    }

    private int stringLengthInPixels(String string) {
        return this.getFontMetrics(this.getFont()).stringWidth(string);
    }

    public Link getLinkWithID(String ID) {

        //search left links first
        if (leftLinks.containsKey(ID)) {
            return leftLinks.get(ID);
        }


        //search right links
        if (rightLinks.containsKey(ID)) {
            return rightLinks.get(ID);
        }

        //search bottom links
        if (bottomLinks.containsKey(ID)) {
            return bottomLinks.get(ID);
        }

        throw new RuntimeException("LINK WITH ID: " + ID + " NOT FOUND IN DRAGGABLE COMPONENT WITH ID: " + getID());
    }
}
